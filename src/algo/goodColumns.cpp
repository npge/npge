/* Nucleotide PanGenome explorer
 * Copyright (C) 2012-2016 Boris Nagaev
 * See the LICENSE file for terms of use.
 */

#include "goodColumns.hpp"

namespace npge {

bool isColumnGood(const char** rows, int nrows, int i) {
    char first = rows[0][i];
    bool ok = true;
    for (int irow = 0; irow < nrows; irow++) {
        char letter = rows[irow][i];
        ok &= (letter == first);
    }
    return ok && first != '-' && first != 'N';
}

bool isColumnIdentGap(const char** rows, int nrows, int i) {
    bool gap = false;
    int A = 0, T = 0, G = 0, C = 0, N = 0;
    for (int irow = 0; irow < nrows; irow++) {
        char letter = rows[irow][i];
        gap |= (letter == '-');
        A |= (letter == 'A');
        T |= (letter == 'T');
        G |= (letter == 'G');
        C |= (letter == 'C');
        N |= (letter == 'N');
    }
    return gap && (A + T + G + C == 1) && !N;
}

// produced by the following script:
//
// local function log2(x)
//     return math.log(x) / math.log(2)
// end
//
// for gaps = 0, 999 do
//     local score = 1 - log2(gaps + 1) / gaps
//     if gaps == 0 then
//         score = -1
//     end
//     io.write(("%d,"):format(score * 100))
//     if gaps % 10 == 9 then
//         io.write('\n')
//     else
//         io.write(' ')
//     end
// end

const int LOG_SCORE[] = {
-100, 0, 20, 33, 41, 48, 53, 57, 60, 63,
65, 67, 69, 70, 72, 73, 74, 75, 76, 77,
78, 78, 79, 80, 80, 81, 81, 82, 82, 83,
83, 83, 84, 84, 84, 85, 85, 85, 86, 86,
86, 86, 87, 87, 87, 87, 87, 88, 88, 88,
88, 88, 88, 89, 89, 89, 89, 89, 89, 89,
90, 90, 90, 90, 90, 90, 90, 90, 91, 91,
91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
92, 92, 92, 92, 93, 93, 93, 93, 93, 93,
93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
93, 93, 93, 93, 93, 94, 94, 94, 94, 94,
94, 94, 94, 94, 94, 94, 94, 94, 94, 94,
94, 94, 94, 94, 94, 94, 94, 94, 94, 94,
94, 94, 94, 94, 95, 95, 95, 95, 95, 95,
95, 95, 95, 95, 95, 95, 95, 95, 95, 95,
95, 95, 95, 95, 95, 95, 95, 95, 95, 95,
95, 95, 95, 95, 95, 95, 95, 95, 95, 95,
95, 95, 95, 95, 95, 95, 95, 95, 95, 95,
96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 98, 98, 98,
98, 98, 98, 98, 98, 98, 98, 99, 99, 99,
};
const int LOG_SCORE_SIZE = 1000;

static void mapGap(Scores& scores, int start, int length,
                   int min_identity, int min_length) {
    int end = start + length;
    if (length >= LOG_SCORE_SIZE) {
        length = LOG_SCORE_SIZE - 1;
    }
    int score = LOG_SCORE[length];
    // for gap columns, multiply score by min_ident
    score = (score == MAX_COLUMN_SCORE) ? score :
        (score * min_identity / MAX_COLUMN_SCORE);
    if (length >= min_length) {
        // length of gap can't be >= min_length
        score = -100 * MAX_COLUMN_SCORE;
    }
    for (int i = start; i < end; i++) {
        scores[i] = score;
    }
}

Scores goodColumns(const char** rows, int nrows, int length,
                   int min_identity, int min_length) {
    if (min_length == -1) {
        // longest than all possible gaps
        min_length = length;
    }
    if (min_identity == -1) {
        // doesn't change score of gapped columns
        min_identity = MAX_COLUMN_SCORE;
    }
    Scores scores(length);
    int gap_length = 0;
    for (int i = 0; i < length; i++) {
        bool good = isColumnGood(rows, nrows, i);
        bool ident_gap = isColumnIdentGap(rows, nrows, i);
        if (good) {
            scores[i] = MAX_COLUMN_SCORE;
        }
        if (ident_gap) {
            gap_length += 1;
        } else if (gap_length > 0) {
            mapGap(scores, i - gap_length, gap_length,
                   min_identity, min_length);
            gap_length = 0;
        }
    }
    if (gap_length > 0) {
        mapGap(scores, length - gap_length, gap_length,
               min_identity, min_length);
        gap_length = 0;
    }
    return scores;
}

}
