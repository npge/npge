/*
 * NPG-explorer, Nucleotide PanGenome explorer
 * Copyright (C) 2014 Boris Nagaev
 *
 * See the LICENSE file for terms of use.
 */

#include "opts_lib.hpp"
#include "throw_assert.hpp"
#include "Meta.hpp"

namespace npge {

static int get_max_errors(const Meta* meta) {
    int batch = meta->get_opt("EXPANDER_BATCH").as<int>();
    double min_identity = meta->get_opt("MIN_IDENTITY").as<double>();
    return batch * (1.0 - min_identity) + 1;
}

void add_opts(Meta* meta) {
    meta->set_opt("LOG_TO", std::string("${LOG_TO}"),
                  "Where to write log messages");
    meta->set_opt("WORKERS", int(${WORKERS}),
                  "Number of threads");
    meta->set_opt("TIMING", bool(${TIMING}),
                  "Log begin/end of calls and "
                  "final time summary");
    meta->set_opt("MIN_LENGTH", int(${MIN_LENGTH}),
                  "Minimum acceptable length of fragment");
    meta->set_opt("MIN_IDENTITY", double(${MIN_IDENTITY}),
                  "Minimum acceptable identity of block");
    meta->set_opt("MAX_EVALUE", double(${MAX_EVALUE}),
                  "Maximum acceptable e-value");
    meta->set_opt("MAX_SPREADING", double(${MAX_SPREADING}),
                  "Maximum acceptable distance spreading "
                  "of fragments in block");
    meta->set_opt("MAX_GAPS", double(${MAX_GAPS}),
                  "Maximum acceptable percentage of "
                  "gap positions");
    meta->set_opt("EXPANDER_BATCH", int(${EXPANDER_BATCH}),
                  "Pair alignment expander batch size");
    meta->set_opt("EXPANDER_MAX_OVERLAP",
                  int(${EXPANDER_MAX_OVERLAP}),
                  "Neighbors overlaps when expanding");
    meta->set_opt("META_ALIGNER",
                  std::string("${META_ALIGNER}"),
                  "Default aligner");
    meta->set_opt("FALLBACK_ALIGNER",
                  std::string("${FALLBACK_ALIGNER}"),
                  "Try external aligner; if fails, "
                  "use similar aligner");
    meta->set_opt("MAFFT_CMD", std::string("${MAFFT_CMD}"),
                  "Mafft command template");
    meta->set_opt("MUSCLE_CMD", std::string("${MUSCLE_CMD}"),
                  "Muscle command template");
    meta->set_opt("EXTERNAL_ALIGNER_CMD",
                  std::string("${EXTERNAL_ALIGNER_CMD}"),
                  "ExternalAligner command template "
                  "Use %1% as input of aligner, "
                  "%2% as output");
    meta->set_opt_func("ALIGNER_MAX_ERRORS",
                       boost::bind(get_max_errors, meta));
    meta->set_description("ALIGNER_MAX_ERRORS",
                          "Max number of errors in "
                          "pair alignment");
    meta->set_opt("ALIGNER_GAP_RANGE",
                  int(${ALIGNER_GAP_RANGE}),
                  "Max distance from main diagonal "
                  "of considered states of pair alignment");
    meta->set_opt("ALIGNER_GAP_PENALTY",
                  int(${ALIGNER_GAP_PENALTY}),
                  "Gap penalty for aligner");
    meta->set_opt("ALIGNER_MISMATCH_PENALTY",
                  int(${ALIGNER_MISMATCH_PENALTY}),
                  "Mismatch penalty for aligner");
    meta->set_opt("BOUNDARIES_MIN_DISTANCE",
                  int(${BOUNDARIES_MIN_DISTANCE}),
                  "Min distance between fragment boundaries "
                  "(overlaps resolver 2)");
    meta->set_opt("JOINER_MAX_DIST",
                  int(${JOINER_MAX_DIST}),
                  "Maximum distance between joint fragments");
    meta->set_opt("JOINER_RATIO_TO_FRAGMENT",
                  double(${JOINER_RATIO_TO_FRAGMENT}),
                  "Max allowed gap length to fragment "
                  "length ratio");
    meta->set_opt("JOINER_GAP_RATIO",
                  double(${JOINER_GAP_RATIO}),
                  "Max allowed ratio of gaps' lengths "
                  "(inside a block)");
    meta->set_opt("SPLIT_REPEATS_MIN_MUTATIONS",
                  int(${SPLIT_REPEATS_MIN_MUTATIONS}),
                  "Min number of mutations in candidate "
                  "block to be splited");
    meta->set_opt("SPLIT_REPEATS_MIN_DIAGNOSTIC_MUTATIONS",
                  int(${SPLIT_REPEATS_MIN_DIAGNOSTIC_MUTATIONS}),
                  "Min number of diagnostic mutations "
                  "in part of splitted block");
    meta->set_opt("MISMATCH_CHECK", int(${MISMATCH_CHECK}),
                  "Min number of equal columns "
                  "after single mismatch");
    meta->set_opt("GAP_CHECK", int(${GAP_CHECK}),
                  "Min number of equal columns "
                  "after single gap");
    meta->set_opt("ALIGNED_CHECK", int(${ALIGNED_CHECK}),
                  "Min equal aligned part");
    meta->set_opt("BLAST_PLUS", bool(${BLAST_PLUS}),
                  "Use blast+ instead of blast");
    meta->set_opt("BLAST_EVALUE", double(${BLAST_EVALUE}),
                  "E-value filter for blast");
    meta->set_opt("BLAST_DUST", bool(${BLAST_DUST}),
                  "E-value filter out low complexity regions");
    meta->set_opt("CONFIG0", std::string("${CONFIG0}"),
                  "Config file 0");
    meta->set_opt("CONFIG1", std::string("${CONFIG1}"),
                  "Config file 0");
    meta->set_opt("CONFIG2", std::string("${CONFIG2}"),
                  "Config file 0");
    meta->set_opt("CONFIG3", std::string("${CONFIG3}"),
                  "Config file 0");
    meta->set_opt("CONFIG4", std::string("${CONFIG4}"),
                  "Config file 0");
    meta->set_opt("CONFIG5", std::string("${CONFIG5}"),
                  "Config file 0");
    meta->set_opt("CONFIG6", std::string("${CONFIG6}"),
                  "Config file 0");
    meta->set_opt("CONFIG7", std::string("${CONFIG7}"),
                  "Config file 0");
    meta->set_opt("CONFIG8", std::string("${CONFIG8}"),
                  "Config file 0");
    meta->set_opt("CONFIG9", std::string("${CONFIG9}"),
                  "Config file 0");
    meta->set_opt("LOCAL_CONF", std::string("${LOCAL_CONF}"),
                  "Local config file name");
}

}

