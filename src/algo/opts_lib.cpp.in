/*
 * NPG-explorer, Nucleotide PanGenome explorer
 * Copyright (C) 2014 Boris Nagaev
 *
 * See the LICENSE file for terms of use.
 */

#include <boost/algorithm/string/replace.hpp>

#include "opts_lib.hpp"
#include "throw_assert.hpp"
#include "Meta.hpp"
#include "Decimal.hpp"
#include "name_to_stream.hpp"

namespace npge {

static std::string local_conf_("${LOCAL_CONF}");

void set_local_conf(const std::string& conf) {
    local_conf_ = conf;
}

static AnyAs local_conf() {
    return local_conf_;
}

static std::string find_tool(const std::string& tool) {
    std::string app_dir = get_app_dir();
    std::string app_tool = cat_paths(app_dir, tool);
    if (file_exists(app_tool)) {
        return escape_path(app_tool);
    }
    std::string app_tool_exe = app_tool + ".exe";
    if (file_exists(app_tool_exe)) {
        return escape_path(app_tool_exe);
    }
    std::string app_tool_EXE = app_tool + ".EXE";
    if (file_exists(app_tool_EXE)) {
        return escape_path(app_tool_EXE);
    }
    std::string app_tool_bat = app_tool + ".bat";
    if (file_exists(app_tool_bat)) {
        return escape_path(app_tool_bat);
    }
    std::string app_tool_BAT = app_tool + ".BAT";
    if (file_exists(app_tool_BAT)) {
        return escape_path(app_tool_BAT);
    }
    return tool;
}

static int get_ALIGNER_MAX_ERRORS(const Meta* meta) {
    int batch = meta->get_opt("EXPANDER_BATCH").as<int>();
    Decimal min_identity;
    min_identity = meta->get_opt("MIN_IDENTITY").as<Decimal>();
    return ((D(1.0) - min_identity) * batch).to_i() + 1;
}

static bool get_BLAST_PLUS(const Meta* meta) {
    int batch = meta->get_opt("EXPANDER_BATCH").as<int>();
    Decimal min_identity;
    min_identity = meta->get_opt("MIN_IDENTITY").as<Decimal>();
    return ((D(1.0) - min_identity) * batch).to_i() + 1;
}

#define CMD_FUNC(name) \
static std::string get_##name##_CMD(const Meta* meta) { \
    std::string tmp = meta->get_opt(#name"_TMP").to_s(); \
    std::string exe = meta->get_opt(#name"_EXE").to_s(); \
    using namespace boost::algorithm; \
    replace_first(tmp, "{"#name"}", exe); \
    return tmp; \
}

CMD_FUNC(MAFFT)
CMD_FUNC(MUSCLE)
CMD_FUNC(FORMATDB)
CMD_FUNC(MAKEBLASTDB)
CMD_FUNC(BLASTALL)
CMD_FUNC(BLASTN)

#define GEN(opt, descr) \
    meta->set_opt_func(#opt, boost::bind(get_##opt, meta)); \
    meta->set_description(#opt, descr)

void add_opts(Meta* meta) {
    meta->set_opt("LOG_TO", std::string("${LOG_TO}"),
                  "Where to write log messages");
    meta->set_opt("DEV_NULL", std::string("${DEV_NULL}"),
                  "Null device");
    meta->set_opt("WORKERS", int(${WORKERS}),
                  "Number of threads (-1 = number of cores)");
    meta->set_opt("BLOCKS_IN_GROUP", int(${BLOCKS_IN_GROUP}),
                  "Number of blocks processing at once "
                  "(BlocksJobs)");
    meta->set_opt("TIMING", bool(${TIMING}),
                  "Log begin/end of calls and "
                  "final time summary");
    meta->set_opt("NPGE_DEBUG", bool(${NPGE_DEBUG}),
                  "Debug mode");
    meta->set_opt("MIN_LENGTH", int(${MIN_LENGTH}),
                  "Minimum acceptable length of fragment");
    meta->set_opt("MIN_IDENTITY", D(${MIN_IDENTITY}),
                  "Minimum acceptable identity of block");
    meta->set_opt("ANCHOR_SIZE", int(${ANCHOR_SIZE}),
                  "Anchor size (AnchorFinder)");
    meta->set_opt("ANCHOR_FP", D(${ANCHOR_FP}),
                  "Probability of false positive in "
                  "Bloom filter");
    meta->set_opt("MAX_ANCHOR_FRAGMENTS",
                  int(${MAX_ANCHOR_FRAGMENTS}),
                  "Maximum number of anchors fragments");
    meta->set_opt("MAX_EVALUE", D(${MAX_EVALUE}),
                  "Maximum acceptable e-value");
    meta->set_opt("MAX_SPREADING", D(${MAX_SPREADING}),
                  "Maximum acceptable distance spreading "
                  "of fragments in block");
    meta->set_opt("MAX_GAPS", D(${MAX_GAPS}),
                  "Maximum acceptable percentage of "
                  "gap positions");
    meta->set_opt("EXPANDER_BATCH", int(${EXPANDER_BATCH}),
                  "Pair alignment expander batch size");
    meta->set_opt("EXPANDER_MAX_OVERLAP",
                  int(${EXPANDER_MAX_OVERLAP}),
                  "Neighbors overlaps when expanding");
    meta->set_opt("META_ALIGNER",
                  std::string("${META_ALIGNER}"),
                  "Default aligner");
    meta->set_opt("FALLBACK_ALIGNER",
                  std::string("${FALLBACK_ALIGNER}"),
                  "Try external aligner; if fails, "
                  "use similar aligner");
    meta->set_opt("EXTERNAL_ALIGNER_CMD",
                  std::string("${EXTERNAL_ALIGNER_CMD}"),
                  "ExternalAligner command "
                  "Use %1% as input of aligner, "
                  "%2% as output");
    GEN(ALIGNER_MAX_ERRORS, "Max number of errors in "
        "pair alignment");
    meta->set_opt("ALIGNER_GAP_RANGE",
                  int(${ALIGNER_GAP_RANGE}),
                  "Max distance from main diagonal "
                  "of considered states of pair alignment");
    meta->set_opt("ALIGNER_GAP_PENALTY",
                  int(${ALIGNER_GAP_PENALTY}),
                  "Gap penalty for aligner");
    meta->set_opt("ALIGNER_MISMATCH_PENALTY",
                  int(${ALIGNER_MISMATCH_PENALTY}),
                  "Mismatch penalty for aligner");
    meta->set_opt("BOUNDARIES_MIN_DISTANCE",
                  int(${BOUNDARIES_MIN_DISTANCE}),
                  "Min distance between fragment boundaries "
                  "(overlaps resolver 2)");
    meta->set_opt("JOINER_MAX_DIST",
                  int(${JOINER_MAX_DIST}),
                  "Maximum distance between joint fragments");
    meta->set_opt("JOINER_RATIO_TO_FRAGMENT",
                  D(${JOINER_RATIO_TO_FRAGMENT}),
                  "Max allowed gap length to fragment "
                  "length ratio");
    meta->set_opt("JOINER_GAP_RATIO",
                  D(${JOINER_GAP_RATIO}),
                  "Max allowed ratio of gaps' lengths "
                  "(inside a block)");
    meta->set_opt("SPLIT_REPEATS_MIN_MUTATIONS",
                  int(${SPLIT_REPEATS_MIN_MUTATIONS}),
                  "Min number of mutations in candidate "
                  "block to be splited");
    meta->set_opt("SPLIT_REPEATS_MIN_DIAGNOSTIC_MUTATIONS",
                  int(${SPLIT_REPEATS_MIN_DIAGNOSTIC_MUTATIONS}),
                  "Min number of diagnostic mutations "
                  "in part of splitted block");
    meta->set_opt("MISMATCH_CHECK", int(${MISMATCH_CHECK}),
                  "Min number of equal columns "
                  "after single mismatch");
    meta->set_opt("GAP_CHECK", int(${GAP_CHECK}),
                  "Min number of equal columns "
                  "after single gap");
    meta->set_opt("ALIGNED_CHECK", int(${ALIGNED_CHECK}),
                  "Min equal aligned part");
    meta->set_opt("BLAST_EVALUE", D(${BLAST_EVALUE}),
                  "E-value filter for blast");
    meta->set_opt("BLAST_DUST", bool(${BLAST_DUST}),
                  "E-value filter out low complexity regions");
    meta->set_opt("MAX_TAIL", int(${MAX_TAIL}),
                  "Max length of tail (MoveGaps)");
    meta->set_opt("MAX_TAIL_TO_GAP", D(${MAX_TAIL_TO_GAP}),
                  "Max tail length to gap length ratio "
                  "(MoveGaps)");
    meta->set_opt("MAX_MATCHES", int(${MAX_MATCHES}),
                  "Maximum number of matches (FragmentFinder)");
    //
    meta->set_opt("CONFIG0", std::string("${CONFIG0}"),
                  "Config file 0");
    meta->set_opt("CONFIG1", std::string("${CONFIG1}"),
                  "Config file 1");
    meta->set_opt("CONFIG2", std::string("${CONFIG2}"),
                  "Config file 2");
    meta->set_opt("CONFIG3", std::string("${CONFIG3}"),
                  "Config file 3");
    meta->set_opt("CONFIG4", std::string("${CONFIG4}"),
                  "Config file 4");
    meta->set_opt("CONFIG5", std::string("${CONFIG5}"),
                  "Config file 5");
    meta->set_opt("CONFIG6", std::string("${CONFIG6}"),
                  "Config file 6");
    meta->set_opt("CONFIG7", std::string("${CONFIG7}"),
                  "Config file 7");
    meta->set_opt("CONFIG8", std::string("${CONFIG8}"),
                  "Config file 8");
    meta->set_opt("CONFIG9", std::string("${CONFIG9}"),
                  "Config file 9");
    meta->set_opt_func("LOCAL_CONF", &local_conf);
    meta->set_description("LOCAL_CONF",
                          "Local config file name");
    //
    meta->set_opt("MAFFT_TMP", std::string("${MAFFT_TMP}"),
                  "Mafft command template");
    meta->set_opt("MUSCLE_TMP", std::string("${MUSCLE_TMP}"),
                  "Muscle command template");
    meta->set_opt("MAFFT_EXE", find_tool("mafft"),
                  "Mafft executable");
    meta->set_opt("MUSCLE_EXE", find_tool("muscle"),
                  "Muscle executable");
    GEN(MAFFT_CMD, "Mafft command");
    GEN(MUSCLE_CMD, "Muscle command");
    //
    std::string formatdb_exe = find_tool("formatdb");
    std::string blastall_exe = find_tool("blastall");
    std::string makeblastdb_exe = find_tool("makeblastdb");
    std::string blastn_exe = find_tool("blastn");
    meta->set_opt("FORMATDB_EXE", formatdb_exe,
                  "formatdb executable (legacy blast)");
    meta->set_opt("BLASTALL_EXE", blastall_exe,
                  "blastall executable (legacy blast)");
    meta->set_opt("MAKEBLASTDB_EXE", makeblastdb_exe,
                  "makeblastdb executable (blast+)");
    meta->set_opt("BLASTN_EXE", blastn_exe,
                  "blastn executable (blast+)");
    meta->set_opt("FORMATDB_TMP",
                  std::string("${FORMATDB_TMP}"),
                  "formatdb command template (legacy blast)");
    meta->set_opt("MAKEBLASTDB_TMP",
                  std::string("${MAKEBLASTDB_TMP}"),
                  "makeblastdb command template (blast+)");
    meta->set_opt("BLASTALL_TMP",
                  std::string("${BLASTALL_TMP}"),
                  "blastall command template (legacy blast)");
    meta->set_opt("BLASTN_TMP",
                  std::string("${BLASTN_TMP}"),
                  "blastn command template (blast+)");
    GEN(FORMATDB_CMD, "formatdb command");
    GEN(MAKEBLASTDB_CMD, "makeblastdb command");
    GEN(BLASTALL_CMD, "blastall command");
    GEN(BLASTN_CMD, "blastn command");
    bool formatdb = formatdb_exe != "formatdb";
    bool makeblastdb = makeblastdb_exe != "makeblastdb";
    bool blastall = blastall_exe != "blastall";
    bool blastn = blastn_exe != "blastn";
    bool blast_legacy = formatdb && blastall;
    bool blast_plus = makeblastdb && blastn;
    bool blast_default = blast_legacy == blast_plus;
    bool BLAST_PLUS = bool(${BLAST_PLUS});
    if (!blast_default && blast_legacy) {
        BLAST_PLUS = 0;
    }
    if (!blast_default && blast_plus) {
        BLAST_PLUS = 1;
    }
    meta->set_opt("BLAST_PLUS", BLAST_PLUS,
                  "Use blast+ instead of blast");
}

}

